{% extends "base.html" %}
{% block title %}Index{% endblock %}
{% block head %}
    {{ super() }}
    <style type="text/css">
        .important {
            color: #ffa07a;
        }
    </style>
{% endblock %}
{% block content %}

<div class="container">

    <h1 class="mt-5 mb-4" style="background-color:lightsalmon;">SOLID Principles</h1>

    <div class="row" style="">
        <div class="col-sm-8">
            <h2 class="mt-3" style="background-color:lightsalmon;">S (Single Responsibility Principle)</h2>

            <p>
                The Single Responsibility Principle requires that a class should have only one job.
                So if a class has more than one responsibility, it becomes coupled. A change to one responsibility
                results to modification of the other responsibility.
                This principle helps to localize errors and makes it easier to reuse the code.
                Any error in execution will point out to a smaller section of your code, accelerating your debug phase.
            </p>
            <p>
            <ul>
                <li>Lets take a look at the example shown on the right side of the page</li>
                <li>The function of the division class is to call the division method by getting the values from the
                    calculation class.
                </li>
                <li>It cannot do anything else except division</li>
            </ul>
            </p>
        </div>

        <div class="col-sm-4">
            <img src="Images/sr.JPG" alt="Parent Class" style="height: 90%" class="mt-3">
            <span style="font-weight: bold">Single Responsibility</span>

        </div>
    </div>
</div>

<div class="w-100 bg-orange-light py-5">
    <div class="container" style="">
        <div class="row mt-3">
            <div class="col-sm-8">
                <h2 style="background-color:lightsalmon;">O (Open and Close Principle)</h2>

                <p>
                    Software entities(Classes, modules, functions) should be open for extension, not modification.
                    You should not need to modify the code you have already written to accommodate new functionality,
                    but simply add what you now need.
                    This does not mean that you cannot change your code when the code premises needs to be modified, but
                    that if you need to add new functions similar to the one present, you should not require to change
                    other parts of the code.
                </p>
                <p>
                <ul>
                    <li>Lets take a look at the example shown on the right side of the page</li>
                    <li>There are bunch of methods in the calculation class. We cannot write those methods in just one
                        method, instead we can just extend it to add more functionality.
                    </li>
                </ul>
                </p>
            </div>

            <div class="col-sm-4">
                <img src="Images/OC.JPG" style="height: 100%" alt="Encapsulation">
                <span style="font-weight: bold">Open and Close Example</span>
            </div>
        </div>
    </div>
</div>
<div class="container" style="">
    <div class="row mt-4">
        <div class="col-sm-8">
            <h3 style="background-color:lightsalmon;">L (Liskov Substitution Principle)</h3>

            <P>
                This Principle states that a child class must be substitutable for its parent class.
                It also aims to ensure that the child class can assume the place of its parent class without causing any
                errors.

            </P>
            <p>
            <ul>
                <li>Lets take a look at the example shown on the right side of the page</li>
                <li>The addition class can work itself and it won't break anything in its parent class if something goes
                    wrong.
                </li>
            </ul>
            </p>
        </div>

        <div class="col-sm-4">
            <img src="Images/lsp.JPG" alt="Abstraction">
            <span style="font-weight: bold">Liskov Substitution Example</span>
        </div>
    </div>

</div>
<div class="w-100 bg-orange-light py-5">
    <div class="container" style="">
        <div class="row mt-3">
            <div class="col-sm-8">
                <h2 style="background-color:lightsalmon;">I (Interface Segregation Principle)</h2>

                <p>
                    The interface segregation principle states that an interface should be as small a possible in terms
                    of cohesion.
                    In other words, it should do ONE thing.
                    It doesn’t mean that the interface should have one method. An interface can have multiple cohesive
                    methods.
                </p>
                <p>
                <ul>
                    <li>To show a good example of this principle, look at the picture in the right.</li>
                    <li>The interface segregation principle uses class and interface.</li>
                    <Li>In this design, the Car only need to implement the go() method that it needs.
                        It doesn’t need to implement the fly() method that it doesn’t use.
                    </Li>
                </ul>
                </p>
            </div>

            <div class="col-sm-4">
                <img src="Images/isp.JPG" style="height: 100%" alt="Interface">
                <span style="font-weight: bold">Interface Segregation Example</span>
            </div>
        </div>
    </div>
</div>
<div class="w-100 bg-orange-light py-5">
    <div class="container" style="">
        <div class="row mt-3">
            <div class="col-sm-8">
                <h2 style="background-color:lightsalmon;">D (Dependency Inversion Principle)</h2>

                <p>
                    The dependency inversion principle states that: High-level modules should not depend on the
                    low-level modules. Both should depend on abstractions.
                    Abstractions should not depend on details. Details should depend on abstractions.
                    The dependency inversion principle aims to reduce the coupling between classes by creating an
                    abstraction layer between them.
                </p>
                <p>
                <ul>
                    <li>Lets take a look at the example on the right side of the page.</li>
                    <li>During the development of the calculator, we didn't edit much in the high level class.</li>
                    <Li>We called methods like addition, subtraction, division, etc., from abstraction and created a low
                        level classes ("class subtraction(calculation))
                    </Li>
                </ul>
                </p>
            </div>

            <div class="col-sm-4">
                <img src="Images/Dependancy.png" style="height: 100%" alt="dependency">
                <span style="font-weight: bold">Dependency Inversion Example</span>
            </div>
        </div>
    </div>
</div>
{% endblock %}